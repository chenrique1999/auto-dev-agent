import 'dotenv/config';
import OpenAI from 'openai';
import { execa } from 'execa';
import { promises as fs } from 'fs';
import path from 'path';
import simpleGit from 'simple-git';
import { fetch } from 'undici';

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const REPO_DIR = process.env.REPO_DIR;
const MODEL = process.env.MODEL || 'gpt-5-mini';

async function run(cmd, cwd = REPO_DIR) {
  try {
    const { stdout, stderr, exitCode } = await execa(cmd, { shell: true, cwd });
    return { ok: exitCode === 0, stdout, stderr, exitCode };
  } catch (e) {
    return { ok: false, stdout: e.stdout || '', stderr: e.stderr || String(e), exitCode: e.exitCode ?? -1 };
  }
}
async function exists(p) { try { await fs.access(p); return true; } catch { return false; } }
async function writeFileSafe(relPath, content, mode = 'replace') {
  const abs = path.join(REPO_DIR, relPath);
  await fs.mkdir(path.dirname(abs), { recursive: true });
  if (mode === 'append' && (await exists(abs))) {
    const prev = await fs.readFile(abs, 'utf8');
    await fs.writeFile(abs, prev + content, 'utf8');
  } else {
    await fs.writeFile(abs, content, 'utf8');
  }
  return `wrote ${relPath} (${content.length} chars)`;
}
async function readFileSafe(relPath, maxBytes = 200000) {
  const abs = path.join(REPO_DIR, relPath);
  const buf = await fs.readFile(abs);
  return buf.slice(0, maxBytes).toString('utf8');
}
async function gitCommitPush(message = 'agent: update') {
  const git = simpleGit(REPO_DIR);
  await git.add('.');
  const status = await git.status();
  if (status.staged.length === 0) return 'no changes to commit';
  await git.commit(message);
  try { await git.push(); return `pushed: ${message}`; }
  catch (e) { return `commit ok, push failed: ${e}`; }
}
async function deployRender() {
  const url = process.env.RENDER_DEPLOY_HOOK;
  if (!url) return 'RENDER_DEPLOY_HOOK not set';
  const r = await fetch(url, { method: 'POST' });
  return `render hook status: ${r.status}`;
}
async function deployNetlify(dir = REPO_DIR) {
  if (!process.env.NETLIFY_AUTH_TOKEN || !process.env.NETLIFY_SITE_ID) {
    const out = await run(`netlify deploy --dir="${dir}" --prod`);
    return out.stdout || out.stderr;
  } else {
    const out = await run(`netlify deploy --dir="${dir}" --site ${process.env.NETLIFY_SITE_ID} --prod --auth ${process.env.NETLIFY_AUTH_TOKEN}`);
    return out.stdout || out.stderr;
  }
}

const toolDefs = [
  { type: 'function', function: { name: 'run_shell', description: 'Executa um comando de shell no repo', parameters: { type: 'object', properties: { cmd: { type: 'string' }, cwd: { type: 'string', nullable: true } }, required: ['cmd'] } } },
  { type: 'function', function: { name: 'write_file', description: 'Escreve arquivo relativo ao REPO_DIR', parameters: { type: 'object', properties: { path: { type: 'string' }, content: { type: 'string' }, mode: { type: 'string', enum: ['replace','append'], default: 'replace' } }, required: ['path','content'] } } },
  { type: 'function', function: { name: 'read_file', description: 'Lê arquivo', parameters: { type: 'object', properties: { path: { type: 'string' }, maxBytes: { type: 'integer', default: 200000 } }, required: ['path'] } } },
  { type: 'function', function: { name: 'git_commit_push', description: 'Commit + push', parameters: { type: 'object', properties: { message: { type: 'string' } } } } },
  { type: 'function', function: { name: 'deploy_render', description: 'Dispara deploy no Render', parameters: { type: 'object', properties: {} } } },
  { type: 'function', function: { name: 'deploy_netlify', description: 'Deploy no Netlify via CLI', parameters: { type: 'object', properties: { dir: { type: 'string' } } } } }
];

async function runTask(userText, maxSteps = 20) {
  const sys = { role: 'system', content: [{ type: 'input_text', text:
`Você é um agente de engenharia que trabalha EXCLUSIVAMENTE dentro de ${REPO_DIR}.
Objetivo: implementar o pedido do usuário, rodar install/build/test/lint, ler stderr e corrigir. Deploy só quando explicitamente pedido.
Regras:
- Use as ferramentas disponíveis (run_shell, read/write_file, git_commit_push, deploy_*).
- Não saia de ${REPO_DIR}. Evite comandos destrutivos.
- Explique brevemente cada ação (logs curtos).
- Pare quando os critérios forem atendidos ou ao atingir o limite de passos.` }] };

  let history = [sys, { role: 'user', content: [{ type: 'input_text', text: userText }] }];

  for (let step = 0; step < maxSteps; step++) {
    const res = await client.responses.create({ model: MODEL, input: history, tools: toolDefs, tool_choice: 'auto' });
    const outputs = res.output || [];
    const toolCalls = outputs.filter(o => o.type === 'tool_call');
    const messages = outputs.filter(o => o.type === 'message');

    for (const m of messages) {
      const txt = (m.content || []).map(c => c.text).filter(Boolean).join('\n');
      if (txt) console.log(`[AI] ${txt}`);
    }
    if (!toolCalls.length) return res;

    const toolResults = [];
    for (const call of toolCalls) {
      const { name, arguments: args, id } = call;
      let output = '';
      try {
        if (name === 'run_shell') output = JSON.stringify(await run(args.cmd, args.cwd || REPO_DIR));
        else if (name === 'write_file') output = await writeFileSafe(args.path, args.content, args.mode || 'replace');
        else if (name === 'read_file') output = await readFileSafe(args.path, args.maxBytes || 200000);
        else if (name === 'git_commit_push') output = await gitCommitPush(args.message || 'agent update');
        else if (name === 'deploy_render') output = await deployRender();
        else if (name === 'deploy_netlify') output = await deployNetlify(args.dir);
        else output = `unknown tool: ${name}`;
      } catch (e) { output = `tool error: ${e}`; }
      toolResults.push({ tool_call_id: id, output });
    }
    history.push({ role: 'tool', content: toolResults.map(tr => ({ type: 'output_text', text: JSON.stringify(tr) })) });
  }
  throw new Error('maxSteps reached');
}

if (process.argv[1] === new URL(import.meta.url).pathname) {
  const task = process.argv.slice(2).join(' ') || 'Crie rota /health no Express e rode npm start.';
  console.log('> Task:', task);
  await runTask(task);
}
