// server.mjs — versão estável/limpa
import express from "express";
import process from "process";
import os from "os";
// import { spawn } from 'child_process'; // não precisamos mais
import { runShellSecure, getPolicy } from './agent.mjs';
import crypto from "crypto";
import { fileURLToPath } from "url";
import path from "node:path";
import "dotenv/config";
import fs from 'fs';

// ====== CONFIG ======
const PORT = Number(process.env.AGENT_PORT || process.env.PORT || 7777);
const REPO_DIR = process.env.REPO_DIR || process.cwd();
const TOKEN = (process.env.AGENT_TOKEN || "").trim();

// ====== APP ======
const app = express();
app.disable("x-powered-by");
app.use(express.json({ limit: "1mb" }));

// ====== UTILS ======
const nowISO = () => new Date().toISOString();
const okJson = (res, obj = {}) => res.status(200).json(obj);

class LogList {
  constructor() { this._items = []; }
  push(s) { this._items.push(String(s)); }
  length() { return this._items.length; }
  sliceFrom(cursor) {
    const c = Number(cursor || 0);
    const items = this._items.slice(c);
    const nextCursor = this._items.length;
    return { items, nextCursor };
  }
}

const tasks = new Map(); // id -> { id, status, pid, startedAt, endedAt, exitCode, logs }

// ====== AUTH (Bearer ou X-Agent-Token) ======
function auth(req, res, next) {
  const want = TOKEN;
  if (!want) return res.status(500).json({ error: "missing-agent-token" });

  const a = req.headers.authorization || "";
  const x = req.headers["x-agent-token"];
  let got = "";
  if (a && typeof a === "string" && a.toLowerCase().startsWith("bearer ")) {
    got = a.slice(7).trim();
  } else if (typeof x === "string") {
    got = String(x).trim();
  }

  if (got !== want) {
    return res.status(401).json({
      error: "unauthorized",
      gotLen: got.length, wantLen: want.length,
      gotPrefix: got.slice(0, 12), wantPrefix: want.slice(0, 12)
    });
  }
  next();
}

// ====== DEBUG (sem auth, pra diagnosticar token/headers) ======
app.get("/__debug-token", (req, res) => {
  const want = TOKEN;
  const a = req.headers.authorization || "";
  const got = (a && a.toLowerCase().startsWith("bearer ")) ? a.slice(7).trim() : "";
  return okJson(res, {
    len: want.length,
    prefix: want ? want.slice(0, 12) : "",
    gotPrefix: got ? got.slice(0, 12) : ""
  });
});

app.get("/__echo-auth", (req, res) => {
  okJson(res, {
    authorization: req.headers.authorization || null,
    xAgentToken: req.headers["x-agent-token"] || null
  });
});

// ====== HEALTH ======
app.get("/health", (req, res) => {
  okJson(res, { ok: true, ts: nowISO(), pid: process.pid, cwd: REPO_DIR });
});

// ====== RUN (assíncrono) ======
app.post("/run-async", auth, (req, res) => {
  const task = (req?.body?.task ?? '').toString();
  if (!task.trim()) return res.status(400).json({ error: "missing task" });

  const id = crypto.randomUUID();
  const logs = new LogList();

  const rec = {
    id,
    status: "running",
    pid: null,
    startedAt: nowISO(),
    endedAt: null,
    exitCode: null,
    logs
  };
  tasks.set(id, rec);

  const tag = `[task:${id.slice(0,8)}]`;
  const push = (s) => logs.push(`${tag} ${s}`);

  // Executa com segurança e stream de saída
  (async () => {
    try {
      const pre = getPolicy();
      push(`[policy] safeMode=${pre.SAFE_MODE} repoDir=${pre.REPO_DIR}`);

      const r = await runShellSecure(task, {
        onStdout: (c) => push(String(c).replace(/\r?\n$/, "")),
        onStderr: (c) => push(String(c).replace(/\r?\n$/, "")),
        // timeoutMs: 180000,
        // maxBuffer: 5 * 1024 * 1024,
      });

      rec.exitCode = r.exitCode ?? (r.ok ? 0 : 1);
      rec.status = "finished";
      rec.endedAt = nowISO();
      if (r.timedOut) push("[timeout] processo atingiu limite");
      push(`[exit ${rec.exitCode}]`);
    } catch (err) {
      push(`[error] ${err?.message || err}`);
      rec.status = "finished";
      rec.exitCode = 1;
      rec.endedAt = nowISO();
    }
  })();

  okJson(res, { taskId: id, status: rec.status, pid: rec.pid, startedAt: rec.startedAt });
});

app.post('/recipes/organize', auth, (req, res) => {
  const dry = req?.query?.dry === '1' || req?.body?.dry === true;
  const task = `node src/organize.mjs${dry ? ' --dry' : ''}`;

  const id = crypto.randomUUID();
  const logs = new LogList();
  const rec = { id, status: 'running', pid: null, startedAt: nowISO(), endedAt: null, exitCode: null, logs };
  tasks.set(id, rec);

  const tag = `[task:${id.slice(0,8)}]`;
  const push = (s) => logs.push(`${tag} ${s}`);

  (async () => {
    try {
      const pre = getPolicy();
      push(`[policy] safeMode=${pre.SAFE_MODE} repoDir=${pre.REPO_DIR}`);
      const r = await runShellSecure(task, {
        onStdout: (c) => push(String(c).replace(/\r?\n$/, '')),
        onStderr: (c) => push(String(c).replace(/\r?\n$/, '')),
      });
      rec.exitCode = r.exitCode ?? (r.ok ? 0 : 1);
      rec.status = 'finished';
      rec.endedAt = nowISO();
      if (r.timedOut) push('[timeout] processo atingiu limite');
      push(`[exit ${rec.exitCode}]`);
    } catch (err) {
      push(`[error] ${err?.message || err}`);
      rec.status = 'finished';
      rec.exitCode = 1;
      rec.endedAt = nowISO();
    }
  })();

  okJson(res, { taskId: id, status: rec.status, startedAt: rec.startedAt });
});

app.get('/tasks/:id/logs-json', auth, (req,res) => {
  const t = tasks.get(req.params.id);
  if (!t) return res.status(404).json({ error: 'not found' });
  const cursor = Number(req.query.cursor || 0);
  const { items, nextCursor } = t.logs.sliceFrom(cursor);
  res.json({ items, nextCursor, status: t.status });
});

// ====== STATUS ======
app.get("/tasks/:id/status", auth, (req, res) => {
  const t = tasks.get(req.params.id);
  if (!t) return res.status(404).json({ error: "not found" });
  okJson(res, {
    id: t.id, status: t.status, pid: t.pid,
    startedAt: t.startedAt, endedAt: t.endedAt, exitCode: t.exitCode
  });
});

app.get("/tasks/:id/status-json", auth, (req, res) => {
  const t = tasks.get(req.params.id);
  if (!t) return res.status(404).json({ error: "not found" });
  okJson(res, t);
});

app.get('/openapi.json', (_req, res) => {
  const p = path.resolve(process.cwd(), 'openapi.json');
  if (fs.existsSync(p)) {
    res.type('application/json').send(fs.readFileSync(p, 'utf8'));
  } else {
    res.status(404).json({ error: 'openapi.json not found' });
  }
});

app.post('/recipes/organize', auth, (req, res) => {
  const dry = req?.query?.dry === '1' || req?.body?.dry === true;
  const task = `node src/organize.mjs${dry ? ' --dry' : ''}`;

  const id = crypto.randomUUID();
  const logs = new LogList();
  const rec = { id, status: 'running', pid: null, startedAt: nowISO(), endedAt: null, exitCode: null, logs };
  tasks.set(id, rec);

  const tag = `[task:${id.slice(0,8)}]`;
  const push = (s) => logs.push(`${tag} ${s}`);

  (async () => {
    try {
      const pre = getPolicy();
      push(`[policy] safeMode=${pre.SAFE_MODE} repoDir=${pre.REPO_DIR}`);
      const r = await runShellSecure(task, {
        onStdout: c => push(String(c).replace(/\r?\n$/, '')),
        onStderr: c => push(String(c).replace(/\r?\n$/, '')),
      });
      rec.exitCode = r.exitCode ?? (r.ok ? 0 : 1);
      rec.status = 'finished';
      rec.endedAt = nowISO();
      if (r.timedOut) push('[timeout] processo atingiu limite');
      push(`[exit ${rec.exitCode}]`);
    } catch (err) {
      push(`[error] ${err?.message || err}`);
      rec.status = 'finished'; rec.exitCode = 1; rec.endedAt = nowISO();
    }
  })();

  okJson(res, { taskId: id, status: rec.status, startedAt: rec.startedAt });
});

// ====== LOGS ======
app.get("/tasks/:id/logs-json", auth, (req, res) => {
  const t = tasks.get(req.params.id);
  if (!t) return res.status(404).json({ error: "not found" });
  const cursor = Number(req.query.cursor || 0);
  const { items, nextCursor } = t.logs.sliceFrom(cursor);
  okJson(res, { items, nextCursor, status: t.status });
});

app.get("/tasks/:id/logs-plain", auth, (req, res) => {
  const t = tasks.get(req.params.id);
  if (!t) return res.status(404).end();
  res.setHeader("Content-Type", "text/plain; charset=utf-8");
  res.write(`# status: ${t.status}\n`);
  const { items } = t.logs.sliceFrom(0);
  for (const line of items) res.write(String(line) + "\n");
  res.end();
});

// ====== SSE ======
app.get("/tasks/:id/sse", auth, (req, res) => {
  const t = tasks.get(req.params.id);
  if (!t) return res.status(404).end();

  res.set({
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache, no-transform",
    "Connection": "keep-alive",
    "X-Accel-Buffering": "no"
  });
  res.flushHeaders && res.flushHeaders();

  let cursor = Number(req.query.cursor || 0);
  const keepAlive = setInterval(() => { try { res.write(":\n\n") } catch {} }, 15000);

  const send = () => {
    const { items, nextCursor } = t.logs.sliceFrom(cursor);
    for (const line of items) {
      const b64 = Buffer.from(String(line), "utf8").toString("base64");
      res.write("event: log\n");
      res.write("data: " + JSON.stringify({ b64 }) + "\n\n");
    }
    cursor = nextCursor;
    if (t.status !== "running") {
      res.write("event: done\n");
      res.write("data: " + JSON.stringify({ status: t.status }) + "\n\n");
      clearInterval(keepAlive);
      try { res.end() } catch {}
      return true;
    }
    return false;
  };

  try { send() } catch {}
  const poll = setInterval(() => {
    if (res.writableEnded) { clearInterval(poll); clearInterval(keepAlive); return }
    try {
      const hasNew = (t && t.logs) ? (t.logs.length() > cursor) : false;
      if (hasNew || t.status !== "running") { if (send()) clearInterval(poll); }
    } catch {}
  }, 500);

  req.on("close", () => { clearInterval(poll); clearInterval(keepAlive); });
});

// ====== EXPORT & START ======
export default app;

const isMain =
  process.argv[1] &&
  path.resolve(process.argv[1]) === fileURLToPath(import.meta.url);

if (isMain) {
  app.listen(PORT, "0.0.0.0", () => {
    console.log(`[agent] listening on http://localhost:${PORT}  (cwd=${REPO_DIR}) pid=${process.pid}`);
    if (!TOKEN) console.warn("[agent] WARNING: AGENT_TOKEN ausente!");
  });
}



