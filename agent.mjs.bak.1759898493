import 'dotenv/config';
import OpenAI from 'openai';
import { execa } from 'execa';
import { promises as fs } from 'fs';
import path from 'path';
import simpleGit from 'simple-git';
import { fetch } from 'undici';

const client = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const REPO_DIR = process.env.REPO_DIR;
const MODEL = process.env.MODEL || 'gpt-4o-mini'; // pode trocar

// ---------- helpers ----------
async function run(cmd, cwd = REPO_DIR) {
  try {
    const { stdout, stderr, exitCode } = await execa(cmd, { shell: true, cwd });
    return { ok: exitCode === 0, stdout, stderr, exitCode };
  } catch (e) {
    return { ok: false, stdout: e.stdout || '', stderr: e.stderr || String(e), exitCode: e.exitCode ?? -1 };
  }
}
async function exists(p) { try { await fs.access(p); return true; } catch { return false; } }
async function writeFileSafe(relPath, content, mode = 'replace') {
  const abs = path.join(REPO_DIR, relPath);
  await fs.mkdir(path.dirname(abs), { recursive: true });
  if (mode === 'append' && (await exists(abs))) {
    const prev = await fs.readFile(abs, 'utf8');
    await fs.writeFile(abs, prev + content, 'utf8');
  } else {
    await fs.writeFile(abs, content, 'utf8');
  }
  return `wrote ${relPath} (${content.length} chars)`;
}
async function readFileSafe(relPath, maxBytes = 200000) {
  const abs = path.join(REPO_DIR, relPath);
  const buf = await fs.readFile(abs);
  return buf.slice(0, maxBytes).toString('utf8');
}
async function gitCommitPush(message = 'agent: update') {
  const git = simpleGit(REPO_DIR);
  await git.add('.');
  const status = await git.status();
  if (status.staged.length === 0) return 'no changes to commit';
  await git.commit(message);
  try { await git.push(); return `pushed: ${message}`; }
  catch (e) { return `commit ok, push failed: ${e}`; }
}
async function deployRender() {
  const url = process.env.RENDER_DEPLOY_HOOK;
  if (!url) return 'RENDER_DEPLOY_HOOK not set';
  const r = await fetch(url, { method: 'POST' });
  return `render hook status: ${r.status}`;
}
async function deployNetlify(dir = REPO_DIR) {
  if (!process.env.NETLIFY_AUTH_TOKEN || !process.env.NETLIFY_SITE_ID) {
    const out = await run(`netlify deploy --dir="${dir}" --prod`);
    return out.stdout || out.stderr;
  } else {
    const out = await run(`netlify deploy --dir="${dir}" --site ${process.env.NETLIFY_SITE_ID} --prod --auth ${process.env.NETLIFY_AUTH_TOKEN}`);
    return out.stdout || out.stderr;
  }
}

// ---------- tools ----------
const tools = [
  {
    type: 'function',
    function: {
      name: 'run_shell',
      description: 'Executa um comando de shell no repo',
      parameters: {
        type: 'object',
        properties: { cmd: { type: 'string' }, cwd: { type: 'string' } },
        required: ['cmd']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'write_file',
      description: 'Escreve arquivo relativo ao REPO_DIR',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string' },
          content: { type: 'string' },
          mode: { type: 'string', enum: ['replace', 'append'], default: 'replace' }
        },
        required: ['path', 'content']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'read_file',
      description: 'Lê arquivo',
      parameters: {
        type: 'object',
        properties: { path: { type: 'string' }, maxBytes: { type: 'integer', default: 200000 } },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'git_commit_push',
      description: 'Commit + push',
      parameters: { type: 'object', properties: { message: { type: 'string' } } }
    }
  },
  {
    type: 'function',
    function: {
      name: 'deploy_render',
      description: 'Dispara deploy no Render via hook',
      parameters: { type: 'object', properties: {} }
    }
  },
  {
    type: 'function',
    function: {
      name: 'deploy_netlify',
      description: 'Deploy no Netlify via CLI',
      parameters: { type: 'object', properties: { dir: { type: 'string' } } }
    }
  }
];

// ---------- loop principal ----------
async function runTask(userText, maxSteps = 20) {
  const messages = [
    {
      role: 'system',
      content:
`Você é um agente de engenharia que trabalha EXCLUSIVAMENTE dentro de ${REPO_DIR}.
Objetivo: implementar o pedido do usuário, rodar install/build/test/lint, ler stderr e corrigir. Deploy só quando explicitamente pedido.
Regras:
- Use as ferramentas disponíveis (run_shell, read/write_file, git_commit_push, deploy_*).
- Não saia de ${REPO_DIR}. Evite comandos destrutivos.
- Explique brevemente cada ação (logs curtos).
- Pare quando os critérios forem atendidos ou ao atingir o limite de passos.`
    },
    { role: 'user', content: userText }
  ];

  for (let step = 0; step < maxSteps; step++) {
    const resp = await client.chat.completions.create({
      model: MODEL,
      messages,
      tools,
      tool_choice: 'auto'
    });

    const msg = resp.choices[0].message;

    // log curto
    if (msg.content) console.log(`[AI] ${msg.content}`);

    // 1) adicione a resposta do assistente (inclui tool_calls) ao histórico
    messages.push(msg);

    const calls = msg.tool_calls ?? [];
    if (!calls.length) return resp; // terminou

    // 2) execute cada tool_call e retorne mensagens role:"tool" com o MESMO id
    for (const call of calls) {
      const { name, arguments: argStr } = call.function;
      const tool_call_id = call.id;
      let args = {};
      try { args = JSON.parse(argStr || '{}'); } catch { args = {}; }

      let output = '';
      try {
        if (name === 'run_shell') output = JSON.stringify(await run(args.cmd, args.cwd || REPO_DIR));
        else if (name === 'write_file') output = await writeFileSafe(args.path, args.content, args.mode || 'replace');
        else if (name === 'read_file') output = await readFileSafe(args.path, args.maxBytes || 200000);
        else if (name === 'git_commit_push') output = await gitCommitPush(args.message || 'agent update');
        else if (name === 'deploy_render') output = await deployRender();
        else if (name === 'deploy_netlify') output = await deployNetlify(args.dir);
        else output = `unknown tool: ${name}`;
      } catch (e) {
        output = `tool error: ${e}`;
      }

      messages.push({ role: 'tool', tool_call_id, content: output });
    }
  }

  throw new Error('maxSteps reached');
}

// ---------- CLI ----------
if (process.argv[1] === new URL(import.meta.url).pathname) {
  const task = process.argv.slice(2).join(' ') || 'Crie rota /health no Express e rode npm start.';
  console.log('> Task:', task);
  await runTask(task);
}
